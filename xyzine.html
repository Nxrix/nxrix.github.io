<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>XYZINE</title>

<style>

:root {
  --bg0: #111;
  --bg1: #222;
  --fg0: #eee;
  --gap: 8px;
  --min-cell: 144px;
}
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  background: var(--bg0);
  color: var(--fg0);
  font-family: "Times New Roman", serif;
}
.scroller {
  height: calc(100% - 2px);
  padding: 1px;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  position: relative;
}
.scroller::-webkit-scrollbar {
  display: none;
}
.spacer {
  position: relative;
  width: 100%;
}
.layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  padding: var(--gap);
  box-sizing: border-box;
}
.grid {
  display: grid;
  gap: var(--gap);
}
.grid img {
  background: var(--bg1);
  width: 100%;
  aspect-ratio: 1/1;
  border-radius: 10%;
  user-select: none;
  image-rendering: pixelated;
}

</style>

</head>

<body>

  <div class="scroller" id="scroller">
    <div id="header" style="display:flex;margin:12px 12px 0px 12px;justify-content:space-between;align-items:center;">
      <span style="font-size:32px;font-weight:900;">XYZINE</span>
      <span style="font-size:16px;font-weight:900;" id="time"></span>
    </div>
    <!--div style="display:block;font-size:12px;font-weight:900;margin:0px 12px 0px 12px;">nxrix</div-->
    <div class="spacer" id="spacer">
      <div class="layer">
        <div class="grid" id="grid"></div>
      </div>
    </div>
  </div>

</body>

<script>
  
const xyz_font_buffer = [0,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,0,1,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,1,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,0,1,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,1,1,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,0,0];

  
</script>

<script>

class XYZINE {
  constructor() {
    this.op = [];
    this.val = [];
    this.expf = [];
    this.bfreq = [];
    this.rnds = ((BigInt(Date.now())^BigInt(Math.floor(Math.random()*0xFFFFFFFF)))&0xFFFFFFFFn)|7012135492040785920n;
  }

  rng(s=0n) {
    s = s|7012135492040785920n;
    return () => {
      s = (s*6364136223846793005n+1442695040888963407n)&18446744073709551615n;
      const x = Number(((s>>18n)^s)>>27n)>>>0;
      const r = Number(s>>59n);
      return ((x>>>r)|(x<<((32-r)&31)))>>>0;
    }
  }
  
  srnd(s) {
    this.rnds = (((s!=undefined&&s!=null)?BigInt(s):BigInt(Date.now())^BigInt(Math.floor(Math.random()*0xFFFFFFFF)))&0xFFFFFFFFn)|7012135492040785920n;
  }

  rnd(m) {
    this.rnds = (this.rnds*6364136223846793005n+1442695040888963407n)&18446744073709551615n;
    const x = Number(((this.rnds>>18n)^this.rnds)>>27n)>>>0;
    const r = Number(this.rnds>>59n);
    const o = (((x>>>r)|(x<<((32-r)&31)))>>>0)/0x100000000;
    if (Array.isArray(m)) {
      return m[o*m.length|0];
    } else {
      return o*(m||1);
    }
  }

  get_op() {
    if (this.op.length == 0) {
      this.op = ["+","+","-","*","/","^","^","&","|","%"];
    }
    return this.del(this.op,this.rnd(this.op));
  }

  get_val() {
    if (this.val.length == 0) {
      this.val = [
        "(x-px)","(y-py)",
        "Math.abs(x)","Math.abs(y)",
        "x","y","x","y",
        "3",
        Math.floor(1+this.rnd()* 4),
        Math.floor(1+this.rnd()* 8),
        Math.floor(1+this.rnd()*16),
        Math.floor(1+this.rnd()*64)
      ];
      const freq = 12;
      if (this.rnd()<1/freq) this.val.push("Math.floor(Math.sqrt(x*x+y*y))");
      if (this.rnd()<1/freq) this.val.push("(x*x+y*y)");
      if (this.rnd()<1/freq) this.val.push("Math.floor(Math.sqrt((x-px)^2+(y-py)^2))");
      if (this.rnd()<1/freq) this.val.push("Math.max(Math.abs(x),Math.abs(y))");
      if (this.rnd()<1/freq) this.val.push("Math.min(Math.abs(x),Math.abs(y))");
      if (this.rnd()<1/freq) this.val.push("(Math.abs(x)+Math.abs(y))");
      if (this.rnd()<1/freq) this.val.push("(Math.max(Math.abs(x),Math.abs(y))+Math.min(Math.abs(x),Math.abs(y)))/2");
      if (this.rnd()<1/freq) this.val.push("(x&y)");
      if (this.rnd()<1/freq) this.val.push("(x|y)");
      if (this.rnd()<1/freq) this.val.push("((x*x)>>7)");
      if (this.rnd()<1/freq) this.val.push("((y*y)>>7)");
      if (this.rnd()<1/freq) this.val.push("Math.sign(x)");
      if (this.rnd()<1/freq) this.val.push("Math.sign(y)");
    }
    return this.del(this.val,this.rnd(this.val));
  }

  exp_a_op_b(a,b) {
    const op = this.get_op();
    if (this.safe && (op === "/" || op === "%")) {
      return `((${b}!=0)?(${a}${op}${b}):0)`;
    }
    return `(${a}${op}${b})`;
  }

  exp_max(a,b) {
    return `Math.max(${a},${b})`;
  }

  exp_min(a,b) {
    return `Math.min(${a},${b})`;
  }

  exp_cos(a,b) {
    return `Math.floor(Math.cos(${a}/${b})*${this.get_val()})`;
  }

  exp_atan(a,b) {
    return `Math.floor(Math.atan2(${a},${b})*${this.get_val()})`;
  }

  exp(depth) {
    if (this.bfreq.length == 0) this.bfreq = [1,2,2,3];
    if (depth>this.del(this.bfreq,this.rnd(this.bfreq))) {
      return this.get_val();
    }
    const a = this.exp(depth+1);
    const b = this.exp(depth+1);
    if (this.expf.length == 0) {
      this.expf = [
        this.exp_a_op_b.bind(this),
        this.exp_a_op_b.bind(this),
        this.exp_a_op_b.bind(this),
        this.exp_a_op_b.bind(this),
        this.exp_max.bind(this),
        this.exp_min.bind(this),
        this.exp_cos.bind(this),
        this.exp_atan.bind(this)
      ];
    }
    const ff = this.del(this.expf, this.rnd(this.expf));
    return `(${ff(a,b)})`;
  }

  getx(d,s=0) {
    this.op = [];
    this.val = [];
    this.expf = [];
    this.bfreq = [];
    this.safe = s;
    return this.exp(d);
  }

  del(arr,value) {
    const idx = arr.indexOf(value);
    if (idx!=-1) {
      arr.splice(idx,1);
    }
    return value;
  }
}

const xyz_h2r = (h) => {
  const n = parseInt(h.slice(1), 16);
  return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
}

const xyz_l = (a, b, t) => {
  return Math.round(a + (b - a) * t);
}

const xyz_grad = (v, p = s) => {
  v = Math.min(1, Math.max(0, v));
  const i = Math.min(Math.floor(v * (p.length - 1)), p.length - 2);
  const t = v * (p.length - 1) - i;
  const c1 = xyz_h2r(p[i]);
  const c2 = xyz_h2r(p[i + 1]);
  return [xyz_l(c1.r, c2.r, t), xyz_l(c1.g, c2.g, t), xyz_l(c1.b, c2.b, t)];
}

const palette = [
  [0x1d, 0x18, 0x26],
  [0x8b, 0x7f, 0xb0],
  [0xc3, 0xbe, 0xe5],
  [0xff, 0xe8, 0xe9],
  [0x65, 0x26, 0x4e],
  [0xa0, 0x1a, 0x3d],
  [0xde, 0x1b, 0x45],
  [0xf2, 0x63, 0x7b],
  [0x8b, 0x3f, 0x39],
  [0xbb, 0x45, 0x31],
  [0xef, 0x5d, 0x0e],
  [0xff, 0x95, 0x00],
  [0x00, 0xa0, 0x3d],
  [0x12, 0xd5, 0x00],
  [0xb4, 0xd8, 0x00],
  [0xff, 0xc3, 0x1f],
  [0x00, 0x6e, 0x69],
  [0x00, 0xae, 0x85],
  [0x00, 0xda, 0xa7],
  [0x4f, 0xd6, 0xff],
  [0x2b, 0x27, 0x54],
  [0x3c, 0x51, 0xaf],
  [0x18, 0x88, 0xde],
  [0x00, 0xa9, 0xe1],
  [0x59, 0x3c, 0x97],
  [0x89, 0x44, 0xcf],
  [0xb4, 0x4a, 0xff],
  [0xe9, 0x59, 0xff],
  [0xe7, 0x87, 0x6d],
  [0xff, 0xba, 0x8c],
  [0xff, 0xef, 0x5c],
  [0xff, 0x9c, 0xde]
];
/*[
  0, 20, 4, 5, 6, 10, 11, 15, 14, 13, 17, 18, 19, 23, 22, 21, 20, 0, 24, 25,
  26, 27, 31, 3, 2, 1, 20
].map(
  (i) => "#" + palette[i].map((x) => x.toString(16).padStart(2, "0")).join("")
);*/

const palette2 = palette.map(
  (i) => "#" + i.map((x) => x.toString(16).padStart(2, "0")).join("")
);

const palette_fa = [
  "#1d1826",
  "#2b2754",
  "#65264e",
  "#a01a3d",
  "#de1b45",
  "#ef5d0e",
  "#ff9500",
  "#ffc31f",
  "#b4d800",
  "#12d500",
  "#00ae85",
  "#00daa7",
  "#4fd6ff",
  "#00a9e1",
  "#1888de",
  "#3c51af",
  "#2b2754",
  "#1d1826",
  "#593c97",
  "#8944cf",
  "#b44aff",
  "#e959ff",
  "#ff9cde",
  "#ffe8e9",
  "#c3bee5",
  "#8b7fb0",
  "#2b2754"
];

const xyz_prints = (data,width,height,t,x,y,c,s = 1) => {
  x |= 0;
  y |= 0;
  s |= 0;
  if (s < 1) s = 1;
  t = t == null ? "" : t.toString();
  const pal = palette[c&31];
  const rVal = pal[0];
  const gVal = pal[1];
  const bVal = pal[2];
  const lines = t.split("\n");
  for (let l = 0; l < lines.length; l++) {
    const line = lines[l];
    const cy = y + l * 5 * s;
    for (let i = 0; i < line.length; i++) {
      const code = line.charCodeAt(i);
      const cx = x + i * 4 * s;
      if (code < 32) continue;
      for (let j = 0; j < 5; j++) {
        for (let k = 0; k < 4; k++) {
          const fontIndex = (code - 32) * 4 + j * 380 + k;
          if (xyz_font_buffer[fontIndex] == 1) {
            for (let sy = 0; sy < s; sy++) {
              for (let sx = 0; sx < s; sx++) {
                const px = cx + k * s + sx;
                const py = cy + j * s + sy;
                if (px < 0 || py < 0 || px >= width || py >= height) continue;
                const idx = (py * width + px) * 4;
                data[idx] = rVal;
                data[idx + 1] = gVal;
                data[idx + 2] = bVal;
                data[idx + 3] = 255;
              }
            }
          }
        }
      }
    }
  }
}

const w = 256;
const h = 256;
const w2 = w/2;
const h2 = h/2;
const wxh = w*h;

const canvas = document.createElement("canvas");
canvas.width = w;
canvas.height = h;
const ctx = canvas.getContext("2d");

const img = ctx.createImageData(w,h);
const img_data = img.data;
for (let n=0;n<wxh;n++) {
  img_data[(n<<2)+3] = 255;
}

const zn = new XYZINE();
const vs = new Float32Array(wxh);

let f;

const render = (i,n) => {
  ctx.clearRect(0,0,w,h);
  
  if (i<n) {
    zn.srnd(i);
    const st =  zn.rnd(palette_fa.length  )|0;
    /*const minp = 4;
    const maxp = 8;
    const se = Math.floor(minp+(maxp-minp)*Math.sqrt(zn.rnd(1)));*/
    const pal = palette_fa.slice(st).concat(palette_fa.slice(0,st));
    /*const pal = [];
    const copy = palette_fa.slice();
    for (let i=0;i<4&&copy.length>0;i++) {
      const e = zn.rnd(copy);
      zn.del(copy,e);
      pal.push(e);
    }*/
    zn.srnd(i);
    const expr = zn.getx(0,1);
  
    try {
      f = new Function("x","y","px","py",`return ${expr};`);
      f(0,0,0,0);
    } catch(e) {
      return;
    }
    
    let min = Infinity;
    let max = -Infinity;
    for (let i=0;i<w;i++) {
      const xi = i-w2-0.5;
      for (let j=0;j<h;j++) {
        const yi = j-h2-0.5;
        const v = f(xi,yi,0,0);
        vs[i+j*w] = v;
        if (v<min) min = v;
        if (v>max) max = v;
      }
    }
    for (let n=0;n<wxh;n++) {
      const [r,g,b] = xyz_grad((vs[n]-min)/(max-min)||0,pal);
      const n4 = n<<2;
      img_data[n4  ] = r;
      img_data[n4+1] = g;
      img_data[n4+2] = b;
      //img_data[n4+3] = 255;
    }
  } else {
    for (let n=0;n<wxh;n++) {
      const [r,g,b] = palette[0];
      const n4 = n<<2;
      img_data[n4  ] = r;
      img_data[n4+1] = g;
      img_data[n4+2] = b;
    }
  }
  const txt = i.toString();
  const txtl = txt.length;
  let sc = 5;
  if (txtl>4) sc=Math.max(9-txtl,2);
  const ps = [
    [-sc,-sc],
    [  0,-sc],
    [ sc,-sc],
    [-sc,  0],
    [ sc,  0],
    [-sc, sc],
    [  0, sc],
    [ sc, sc]
  ];
  ps.slice().reverse().forEach(([dx1,dy1],i1) => {
    ps.forEach(([dx2,dy2],i2) => {
      xyz_prints(img_data,w,h,txt,w2+sc/2-2*sc*txtl+dx1+dx2,h2-2*sc+dy1+dy2,i1>4?3:2,sc);
    });
  });
  ps.forEach(([dx,dy],i) => {
    xyz_prints(img_data,w,h,txt,w2+sc/2-2*sc*txtl+dx,h2-2*sc+dy,i<3?20:0,sc);
  });
  xyz_prints(img_data,w,h,txt,w2+sc/2-2*sc*txtl,h2-2*sc,3,sc);
  ctx.putImageData(img,0,0);
  return canvas.toDataURL("image/png");
}

</script>

<script>

const k = new Date("2021-09-26T10:37:00.000+03:30");

const t = () => {
  const d = new Date(Date.now() - k);
  const n = Math.floor(d.getTime() / 1000);
  time.innerText = Math.floor(n / (60 * 60 * 24)).toString() + " " + [d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds()].map(n => n.toString().padStart(2, "0")).join(":");
}
t();
setInterval(t,1000);

const gap = 8;
const min_cell = 144;
const buffer_rows = 8;
const max_index = Math.floor((Date.now()-k)/(1000*60*60*24))-1+8;//365 * 10000;

const scroller = document.getElementById("scroller");
const spacer = document.getElementById("spacer");
const grid = document.getElementById("grid");

const get_n_from_url = () => {
  try {
    return parseInt(new URL(location.href).searchParams.get("n")) || 0;
  } catch (e) {
    return 0;
  }
};

let cols = 1;
let row_h = min_cell + gap;
let vis_rows = 0;
let ticking = false;
let last_n = get_n_from_url();

const rendered = new Map();
const pending = new Map();
let busy = false;

const compute_layout = () => {
  const w = scroller.clientWidth - gap * 2;
  cols = Math.max(1, Math.floor(w / (min_cell + gap)));
  const cell = Math.max(min_cell, (scroller.clientWidth - gap * (cols + 1)) / cols);
  row_h = cell + gap;
  vis_rows = Math.ceil(scroller.clientHeight / row_h);
  grid.style.gridTemplateColumns = `repeat(${cols},1fr)`;
  spacer.style.height = `${Math.ceil(max_index / cols) * row_h}px`;
};

const compute_range = () => {
  const st = scroller.scrollTop;
  const first = Math.ceil(st / row_h);
  const start_row = Math.max(0, first - buffer_rows);
  const end_row = first + vis_rows + buffer_rows;
  return {
    start_row,
    start_idx: start_row * cols,
    end_idx: Math.min(max_index, (end_row + 1) * cols - 1),
    first_visible: Math.round(st / row_h) * cols
  };
};

const set_n_in_url = (n) => {
  if (last_n === n) return;
  last_n = n;
  const u = new URL(location.href);
  u.searchParams.set("n", String(n));
  history.replaceState(null, "", u.toString());
};

const render_range = ({ start_idx, end_idx, start_row }) => {
  grid.parentElement.style.transform = `translateY(${start_row * row_h}px)`;

  for (const [i, el] of rendered) {
    if (i < start_idx || i > end_idx) {
      el.remove();
      rendered.delete(i);
      pending.delete(i);
    }
  }

  for (let i = start_idx; i <= end_idx; i++) {
    if (!rendered.has(i) && !pending.has(i)) {
      const img = document.createElement("img");
      img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWJiYGBgAAAAAP//XRcpzQAAAAZJREFUAwAADwADJDd96QAAAABJRU5ErkJggg==";
      const pos = i - start_idx;
      const children = grid.children;
      if (pos >= children.length) grid.appendChild(img);
      else grid.insertBefore(img, children[pos]);
      rendered.set(i, img);
      pending.set(i, img);
    }
  }

  if (!busy) load_next();
};

/*const load_next = async () => {
  busy = true;
  if (pending.size === 0) {
    busy = false;
    return;
  }

  const vis_start = Math.floor(scroller.scrollTop / row_h) * cols;
  const vis_end = vis_start + Math.ceil(scroller.clientHeight / row_h) * cols;

  let near = null, dist = Infinity;
  for (const idx of pending.keys()) {
    const d = idx < vis_start ? vis_start - idx : idx > vis_end ? idx - vis_end : 0;
    if (d < dist) {
      dist = d;
      near = idx;
    }
  }

  if (near === null) {
    busy = false;
    return;
  }

  const el = pending.get(near);
  pending.delete(near);
  el.src = render(near,max_index-8+1);

  await new Promise(r => requestAnimationFrame(r));
  load_next();
};*/

/*let lastLoaded = null;
const load_next = async () => {
  if (busy) return;
  busy = true;
  if (pending.size === 0) {
    busy = false;
    return;
  }
  const vis_start = Math.floor(scroller.scrollTop / row_h) * cols;
  const vis_end = vis_start + Math.ceil(scroller.clientHeight / row_h) * cols;
  const vis_center = Math.floor((vis_start + vis_end) / 2);
  const start = Math.max(0, vis_start);
  const end = Math.min(max_index + 1, vis_end);
  if (start >= end) {
    busy = false;
    return;
  }
  const mid = Math.floor((start + end) / 2);
  const countLoadedIn = (s, e) => {
    let total = 0;
    let pendingCnt = 0;
    for (let i = s; i < e; i++) {
      if (i < 0 || i > max_index) continue;
      total++;
      if (pending.has(i)) pendingCnt++;
    }
    return total - pendingCnt;
  };
  const aLoaded = countLoadedIn(start, mid);
  const bLoaded = countLoadedIn(mid, end);
  let forward;
  if (aLoaded > bLoaded) forward = true;
  else if (bLoaded > aLoaded) forward = false;
  else {
    if (typeof lastLoaded === 'number') forward = lastLoaded < vis_center;
    else forward = true;
  }
  let next;
  if (forward) {
    next = Array.from(pending.keys()).find(i => i >= start && i < end);
  } else {
    const pendingIndices = Array.from(pending.keys()).filter(i => i >= start && i < end);
    next = pendingIndices.length ? pendingIndices[pendingIndices.length - 1] : undefined;
  }
  if (next === undefined) {
    busy = false;
    return;
  }
  const el = pending.get(next);
  pending.delete(next);
  el.src = render(next, max_index - 8 + 1);
  lastLoaded = next;
  await new Promise(r => requestAnimationFrame(r));
  busy = false;
  load_next();
};*/

const load_next = async () => {
  busy = true;
  if (pending.size === 0) {
    busy = false;
    return;
  }
  const vis_start = Math.floor(scroller.scrollTop / row_h) * cols;
  const vis_end = vis_start + Math.ceil(scroller.clientHeight / row_h) * cols;
  const vis_center = Math.floor((vis_start + vis_end) / 2) - (1 - (cols % 2)) * cols / 2;
  let nextIndex = null;
  let minDist = Infinity;
  for (const idx of pending.keys()) {
    if (idx >= vis_start && idx <= vis_end) {
      const dist = Math.abs(idx - vis_center);
      if (dist < minDist) {
        minDist = dist;
        nextIndex = idx;
      }
    }
  }
  if (nextIndex === null) {
    for (const idx of pending.keys()) {
      const dist = idx < vis_start ? vis_start - idx : idx - vis_end;
      if (dist < minDist) {
        minDist = dist;
        nextIndex = idx;
      }
    }
  }
  if (nextIndex === null) {
    busy = false;
    return;
  }
  const el = pending.get(nextIndex);
  pending.delete(nextIndex);
  el.src = render(nextIndex, max_index - 8 + 1);
  await new Promise(r => requestAnimationFrame(r));
  busy = false;
  load_next();
};

const scroll_to = (n) => {
  const target = Math.floor(Math.min(Math.floor(n/cols)*row_h,spacer.clientHeight-scroller.clientHeight)) + header.clientHeight + 12;
  scroller.scrollTop = Math.max(0, target);
};

const on_scroll_or_resize = () => {
  if (ticking) return;
  ticking = true;
  //requestAnimationFrame(() => {
    const range = compute_range();
    render_range(range);
    set_n_in_url(range.first_visible);
    ticking = false;
  //});
};

const init = () => {
  compute_layout();
  const init_n = get_n_from_url();
  //requestAnimationFrame(() => {
    compute_layout();
    scroll_to(init_n);
    on_scroll_or_resize();
  //});
};

window.addEventListener("scroll",() => {
  on_scroll_or_resize();
});

["resize", "orientationchange"].forEach(ev => {
  /*window.addEventListener(ev, () => requestAnimationFrame(() => {
    compute_layout();
    scroll_to(get_n_from_url() || last_n || 0);
    on_scroll_or_resize();
  }));*/
  window.addEventListener(ev, () => {
    compute_layout();
    scroll_to(get_n_from_url() || last_n || 0);
    on_scroll_or_resize();
  });
});

scroller.addEventListener("scroll", on_scroll_or_resize);
window.addEventListener("load", init);

</script>

</html>










